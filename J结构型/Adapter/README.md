# Adapter(适配器模式)    ---- 结构性模式

适配器模式顾名思义就是，当旧的东西不能直接使用，用于使得现有的旧东西还能运转起来的转换器。通常一个企业所用的库很老旧，而且很多业务也依赖于这些库，当有少量新业务需要开拓，而当前的库已经不满足需求时，问题来了，直接放弃现有的库而去开发新的库吗？风险大，成本高，不稳定。明明只需要加点新东西，没必要去动非常稳定的旧库，最佳解决方法是在旧库的基础上，包装一下，添加一些新功能，又能跑个十来年。

使用适配器模式是不得以的，通常是在增加一丁点新功能时使用，当然，这也是原来框架设计的不好，逼得我们想增加点东西就得这样。要是原来框架设计得当，增加点新功能很简单的事，就跟插件式一眼，想增想减都很任性。如果当前框架已经不满足现有的大部分业务，那肯定选择重构来得爽快，而不是修修补补，补多了最后还得重构，这成本就更高了。


适配器模式通常有两种实现方式，一种是继承，另一种是对象成员。继承使得拥有另一个类的所有功能。而对象成员是在新类中new一个旧类对象。



**继承**

```
class oldclass
{
    // I have many function
}

class newclass: public oldclass
{
    // rewrite oldclass function
}
```

这种方式略显古板，灵活性不太强，很可能每个旧类都得写个新类来包装。


**对象成员**

```
class oldclass
{
    // I have many function
}

class newclass
{
public:
    // I have many function
private:
    oldclass obj;
}
```

这种方式就比较灵活了，对newclass什么限制，可以最大限度地发挥，随时删掉oldclass也是很简单的。

